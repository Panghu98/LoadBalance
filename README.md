# LoadBalance
负载均衡及算法实现

## 负载均衡介绍
负载均衡（Load Balance）,指由多台服务器以堆成的方式组成一个服务器组个，
每台服务器都局域等价的地位，**都可以单独对外提供服务**而无需其他服务器的辅助。

通过某种负载均衡分担技术，将外部发送来的请求均匀分配到某一对称结构中的某台服务器上，
而接收到请求的服务器独立回应客户的请求。

负载均衡能够平均分配客户请求到服务器阵列，借此提供快速获取重要数据，解决大量并发访问服务问题，
这种集群问题技术可以用最少的投资获得最接近大型主机的性能。

## 负载均衡的方式
- 软件负载均衡
- 硬件负载均衡

### 软件负载均衡

### 硬件负载均衡
常见的负载硬件有Array,F5

### 软件负载均衡
常见的负载均衡软件有Nginx、LVS、 HAProxy。

- [Nginx/LVS/HAProxy负 载均衡软件的优缺点详解](http://www.ha97.com/5646.html)

- [三大主流软件负载均衡器对比(LVS、Nginx、Haproxy)](http://www.21yunwei.com/archives/5824)

### 负载均衡算法
常见的负载均衡算法有:随机算法、加权轮询、-致性hash、 最小活跃数算法。
千万别以为这几个算法看.上去都特别简单，但其实真正在生产上用到时会远比你想的复杂

#### 随机算法-RandomLoadBalance

- [无权重随机算法](src/random/Random.java)

当调用次数比较少时，Random 产生的随机数可能会比较集中，此时多数请求会落到同一台服务器上， 只有在
经过多次请求后，才能使调用请求进行均匀”分配。调用量少这一点并没有什么关系，负载均衡机制不正是为
了应对请求量多的情况吗，所以随机算法也是用得比较多的一种算法。

>但是，上面的随机算法适用于每天机器的性能差不多的时候， 实际上，生产中可能某些机器的性能更高一
 点，它可以处理更多的请求，所以，我们可以对每台服务器设置一个权重。



##### 权重随机算法
通过使用hash表来存储服务器的权重，当调用量比较多的时候，服务器使用的分布也应该
近似权重的分布。

- [权重随机算法]()

实现思路：把每个服务器按它所对应的服务器权重进行复制，权重越大，在List当中
的数量越多，然后再0~权重总和之间产生一个随机数，从List当中去获取

>这种实现算法在遇到权重特别大时候，就会比较消耗内存，因为需要对IP地址进行
>复制，权重之和越大那么上文中的ips需要更多的内存

##### 权重随机算法优化
假设我们有一组服务器servers= [A, B, C],他们对应的权重为weights= [5, 3, 2]，权重总和为10。现在把这些
权重值平铺在一维坐标值上, [0, 5)区间属于服务器A, [5, 8)区间属于服务器B, [8, 10)区间属于服务器C。
接下来通过随机数生成器生成一个范围在[0, 10)之间的随机数，然后计算这个随机数会落到哪个区间上。比如
数字3会落到服务器A对应的区间上，此时返回服务器A即可。权重越大的机器，在坐标轴上对应的区间范围
就越大，因此随机数生成器生成的数字就会有更大的概率落到此区间内。只要随机数生成器产生的随机数分布
性很好，在经过多次选择后，每个服务器被选中的次数比例接近其权重比例。比如，经过- -万次选择后，服务
器A被选中的次数大约为5000次，服务器B被选中的次数约为3000次，服务器C被选中的次数约为2000次。
假设现在随机数offset=7:

1. offset<5 is false,所以不在[0, 5)区间，将offset = offset- 5 (offset=2)
2. offset<3 is true,所以处于[5, 8)区间，所以应该选用B服务器

- [权重随机算法优化](src/random/WeightRandomV2.java)

#### 轮询算法 - RoundRobinLoadBalance
轮询算法是最简单的一种负载均衡算法。 它的原理是把来自用户的请求轮流分配给内部的服务器：
从服务器1开始，直到服务器N，然后重新开始循环。 算法的优点是其简洁性，
它无需记录当前所有连接的状态，所以它是一种无状态调度。

- [轮询算法简单实现]()

存在的问题：缺少权重比，每台机器的性能可能存在不同

##### 加权轮询算法
加权轮询算可以通过 `复制法`实现，与[权重随机算法]()类似，这里就不做多余的讲解

这种算法需要加入一个概念:调用编号，比如第1次调用为1，第2次调用为2， 第100次调用为100, 调用编号
是递增的，所以我们可以根据这个调用编号推算出服务器。
假设我们有三台服务器servers= [A, B, C]，对应的权重为weights=[2, 5, 1], 总权重为8,我们可以理解为有8
台“服务器”，这是8台“不具有并发功能”，其中有2台为A，5台为B，1台为C, -次调用过来的时候，需要按顺
序访问，比如有10次调用，那么服务器调用顺序为AABBBBBCAA,调用编号会越来越大，而服务器是固定
的，所以需要把调用编号“缩小”,，这里对调用编号进行取余，除数为总权重和，比如:

的，所以需要把调用编号“缩小”，这里对调用编号进行取余，除数为总权重和，比如:
1. 1号调用，1%8=1;

2. 2号调用，2%8=2;

3.3号调用，3%8=3;

4.8号调用，8%8=0;

5. 9号调用，9%8=1;

6.100号调用，100%8=4;

我们发现调用编号可以被缩小为0-7之间的8个数字，问题是怎么根据这个8个数字找到对应的服务器呢?和我
们随机算法类似，这里也可以把权重想象为一个坐标轴 0---2---7---8
1. 1号调用，1%8=1，offset= 1, offset <= 2 is true, 取A;
2. 2号调用，2%8=2; offset=2， offset<= 2 is true,取A;
3. 3号调用，3%8=3; offset= 3, offset <= 2 is false, offset = offset- 2, offset= 1, offset<= 5，取B
4. 8号调用，8%8=0; offset = 0,特殊情况，offset= 8，offset <= 2 is false, offset = offset- 2, offset= 6,offset <= 5 is false, offset = offset- 5, offset= 1, offset <= 1 is true,取C;

5. 9号调用，9%8=1; //

6. 100号调用，100%8=4; //.

[编号调用轮询实现]()



